# PulumiGen Product Requirements Document

The generation tool should have a command that tasks short name, loads a .net assembly,
inspect the types, generate classes for extenion methods and members, and saves the
files to the right project.

Only one project/assembly should be run at time.

When the generated code references types, the global:: keyword shall be used to avoid namespace
clashes. Any variables or parameter names that are the same as C# keywords shall be prefixed with the
'@' symbol.

Any generated file shall include at the top of the file

```cs
// <auto-generated/>
// Do not edit any code this file. Create or edit the partial class instead in a different file.
```

Any generated code must not have warnings, style issues, or errors.  It should be able to handle
any pulumi assembly that is reference in the PulumiGen csproj folder.

For example, the argument "AzureNative" should tell the program to load the Pulumi.AzureNative
assembly into memory, inspect the types, generate classes and save the files to the
right folders or subfolders in the project Hyprx.Pulumi.AzureNative found
in the folder `./sdk/AzureNative/src`.

When a public class that is not abstract or static is found that inherits from `Pulumi.CustomResource`
a public static class for extensions must be created.  If the class is called Pulumi.AzureNative.Storage.StorageAcount,
then the file should be called StorageAccountExtensions and live with in the Pulumi.AzureNative.Storage namespace
and be saved to the subfolder "Storage" e.g. `./sdk/AzureNative/src/Storage/StorageAccountExtensions.g.cs`

The constructor should be inspected and based upon the arguments in the constructor, static methods called new
will be generated using new "extension" keyword in C#. see extension members:
<https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods>

The extension class for the custom resource should generate a static method called new with two overloads:

```cs

public static partial class StorageAccountExtensions
{
    extension(StorageAccount)
    {
         public static StorageAccount New(string id, StorageAccountArgs? args = null, CustomResourceOptions? options)
         {
             return new(id, args, options);
         }

         public static StorageAccount New(string id, Action<StorageAccountArgs>? configureArgs, Action<CustomResourceOptions>? configureOptions)
         {
            StorageAccountArgs? args = null;
            CustomResourceOptions? options = null;
            if (configureArgs is not null)
            {
                args = new();
                configureArgs(args);
            }

            if (configureOptions is not null)
            {
                options = new();
                configureOptions(options);
            }

            return new(id, args, options);
         }
    }
}

```

When a public class that is not abstract or static is found that inherits from `Pulumi.ResourceArgs`,
a public static class for extensions must be created.  If the class is called Pulumi.AzureNative.Storage.StorageAcountArgs,
then the file should be called StorageAccountArgsExtensions and live with in the Pulumi.AzureNative.Storage namespace
and be saved to the subfolder "Storage" e.g. `./sdk/AzureNative/src/Storage/StorageAccountArgsExtensions.g.cs`

If the class is called Pulumi.AzureNative.Storage.Inputs.AccessPolicyArgs and inherits from Pulumi.ResourceArgs, then
the class called AccessPolicyArgsExtensions and live with in the Pulumi.AzureNative.Storage namespace
and be saved to the subfolder "Storage" e.g. `./sdk/AzureNative/src/Storage/AccessPolicyArgsExtensions.g.cs`

The code should loop over the public properties that are not static and generate fluent methods that use the
"With" prefix.  Any conversion of variables should check the variable name for colliding with c# keywords such
as but not limited to in, out, ref, global, object, event, public, private, implicit, operator, etc.  If a keyword
is found, it should be prefixed with an "@". For example event would become @event. Parameters and variables
shall be camel cased.

For properties that use the generic type `InputUnion<T1, T2>` an extension method shall be created in the class that
passes in the type `Union<T1, T2>` with the full type information such as `Union<string, int>` as the parameter type.

```cs

public static StorageAccountArgs WithPropertyName(this StorageAccountArgs selfRef,  Union<T1, T2> propertyName)
{
    selfRef.PropertyName = propertyName;
    return selfRef;
}
```

For properties that use the generic type `InputList<T>` three extension methods shall be created in the class that
passes in the type `List<T>` and `Action<List<T>>` using the full type information such as `List<string>`.

```cs

public static StorageAccountArgs WithPropertyName(this StorageAccountArgs selfRef, List<T> propertyName)
{
     selfRef.PropertyName = propertyName;
     return selfRef;
}


public static StorageAccountArgs WithPropertyName(this StorageAccountArgs selfRef, Action<List<T>> configure)
{
    var list = new List<T>();
    configure(list);
    selfRef.PropertyName = list;
    return selfRef;
}

public static StorageAccountArgs WithPropertyName(this StorageAccountArgs selfRef, Func<IList<T>> create)
{
    selfRef.PropertyName = create();
    return selfRef;
}
```

For properties that use the generic type `InputMap<T>` three extension methods shall be created in the class that
passes in the type `Dictionary<string, T>` and `Action<Dictionary<string, T>>`.

```cs
public static StorageAccountArgs WithPropertyName(this StorageAccountArgs selfRef, Dictionary<string, T> propertyName)
{
     selfRef.PropertyName = propertyName;
     return selfRef;
}


public static StorageAccountArgs WithPropertyName(this StorageAccountArgs selfRef, Action<Dictionary<string, T>> configure)
{
    var list = new List<T>();
    configure(list);
    selfRef.PropertyName = list;
    return selfRef;
}

public static StorageAccountArgs WithPropertyName(this StorageAccountArgs selfRef, Func<IDictionary<string, T>> create)
{
    selfRef.PropertyName = create();
    return selfRef;
}

```

For properties that are of generic type `Input<T>` and are complex types that are not struct or primitives like bool, string,
DateTime, long, etc, at least two extension methods shall be created.  One that passes in a an arg with the type of T
and other that pass in the arg of type `Action<T>`.

```cs
public static StorageAccountArgs WithPropertyName(this StorageAccountArgs selfRef, T propertyName)
{
     selfRef.PropertyName = propertyName;
     return selfRef;
}


public static StorageAccountArgs WithPropertyName(this StorageAccountArgs selfRef, Action<T> configure)
{
    // if the default is null or the object can not be called with new(), then Activator.Create<T>() shall be used
    var list = default // or Activator.Create<T>() if default results in creating a null9
    configure(list);
    selfRef.PropertyName = list;
    return selfRef;
}

```

For properties that are of generic type `Input<T>` where T is a struct or primitive type like a string, guid,
DateTime, etc, then a single extension method shall be created.  If type of T is boolean or bool, then the argument
shall have the default value of true

For most primitives the extension method looks like the following.

```cs

public static StorageAccountArgs WithPropertyName(this StorageAccountArgs selfRef, T propertyName)
{
     selfRef.PropertyName = propertyName;
     return selfRef;
}

```

For the boolean extension method, it shall look like the following:

```cs

public static StorageAccountArgs WithPropertyName(this StorageAccountArgs selfRef, bool propertyName = true)
{
     selfRef.PropertyName = propertyName;
     return selfRef;
}

```
